<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on WinterCicada&#39;s Blog</title>
    <link>https://blog.wintercicada.xyz/categories/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on WinterCicada&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 22 Mar 2022 11:09:00 +0800</lastBuildDate><atom:link href="https://blog.wintercicada.xyz/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 并发实战</title>
      <link>https://blog.wintercicada.xyz/post/go-concurrency-in-practice/</link>
      <pubDate>Tue, 22 Mar 2022 11:09:00 +0800</pubDate>
      
      <guid>https://blog.wintercicada.xyz/post/go-concurrency-in-practice/</guid>
      <description>&lt;p&gt;Go 语言中推荐在使用并发时使用 Channel 通信而不是共享内存方式来实现各个 Goroutine 相互之间的沟通，这使得它的并发编程会不同于大多数用共享内存方式来实现线程间通信的编程语言。下面将会使用一个驱动案例来介绍 Go 的并发编程常用的一些模式。如果你还没有了解过 Go 的并发，可以读一下&lt;a href=&#34;https://blog.wintercicada.xyz/post/go-concurrency/&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 并发</title>
      <link>https://blog.wintercicada.xyz/post/go-concurrency/</link>
      <pubDate>Sun, 20 Mar 2022 17:07:09 +0800</pubDate>
      
      <guid>https://blog.wintercicada.xyz/post/go-concurrency/</guid>
      <description>&lt;p&gt;Go 作为一个相对较新的语言，能够被许多人接受并大量应用于公司项目中，说明它在某些方面是优于传统的 C++ 与 Java 的，能吸引开发者去应用并学习 Go 语言。而我认为其中最能吸引开发者的特性就是易上手的并发。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>动态规划三步走</title>
      <link>https://blog.wintercicada.xyz/post/dp/</link>
      <pubDate>Thu, 20 Jan 2022 16:53:02 +0800</pubDate>
      
      <guid>https://blog.wintercicada.xyz/post/dp/</guid>
      <description>&lt;p&gt;动态规划一直是算法中比较难的一个，我认为原因有两个：一是动态规划很容易和分治法混淆，二是动态规划的算法比较难以理解，要一步步地优化，最优的动态规划算法难以直接构想出来，只有很熟悉才能做到。下面就从动态规划的定义与三个步骤入手，让动态规划更好理解。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
